diff -urNd a/mongoose.c b/mongoose.c
--- a/mongoose.c	2010-11-07 20:23:41.000000000 +0800
+++ b/mongoose.c	2010-11-08 10:42:16.000000000 +0800
@@ -173,16 +173,18 @@
 #include <pwd.h>
 #include <unistd.h>
 #include <dirent.h>
-#if !defined(NO_SSL_DL) && !defined(NO_SSL)
+#if !defined(NO_SSL_DL) && !defined(NO_SSL) && !defined(NO_LSP_DL) && !defined(NO_LSP)
 #include <dlfcn.h>
 #endif
 #include <pthread.h>
 #if defined(__MACH__)
 #define SSL_LIB   "libssl.dylib"
 #define CRYPTO_LIB  "libcrypto.dylib"
+#define LSP_LIB   "libluasp.dylib"
 #else
 #define SSL_LIB   "libssl.so"
 #define CRYPTO_LIB  "libcrypto.so"
+#define LSP_LIB   "libluasp.so"
 #endif
 #define DIRSEP   '/'
 #define IS_DIRSEP_CHAR(c) ((c) == '/')
@@ -340,6 +342,52 @@
 };
 #endif // NO_SSL_DL
 
+// Snatched from Lua includes.
+typedef struct lua_State lua_State;
+
+#define lua_open() luaL_newstate()
+#define lua_tostring(L,i) lua_tolstring(L, (i), NULL)
+#define lua_pop(L,n) lua_settop(L, -(n)-1)
+
+#if defined(NO_LSP_DL)
+extern lua_State *(luaL_newstate)(void);
+extern void (luaL_openlibs)(lua_State *L);
+extern int luaopen_lualsp(lua_State *L);
+extern int luaL_do_lsp_file(lua_State* L,const char* filename);
+extern const char *(lua_tolstring)(lua_State *L, int idx, size_t *len);
+extern void (lua_settop)(lua_State *L, int idx);
+extern void (lua_close)(lua_State *L);
+#else
+// Dynamically loaded LSP functionality
+struct lsp_func {
+  const char *name;   // LSP function name
+  void  (*ptr)(void); // Function pointer
+};
+
+#define luaL_newstate (* (lua_State * (*)(void)) lsp_sw[0].ptr)
+#define luaL_openlibs (* (void (*)(lua_State *)) lsp_sw[1].ptr)
+#define luaopen_lualsp (* (int (*)(lua_State *)) lsp_sw[2].ptr)
+#define luaL_do_lsp_file (* (int (*)(lua_State* ,const char*)) lsp_sw[3].ptr)
+#define lua_tolstring (* (const char * (*)(lua_State *, int, size_t *)) lsp_sw[4].ptr)
+#define lua_settop (* (void (*)(lua_State *, int)) lsp_sw[5].ptr)
+#define lua_close (* (void (*)(lua_State *)) lsp_sw[6].ptr)
+
+// set_lsp_option() function updates this array.
+// It loads LSP library dynamically and changes NULLs to the actual addresses
+// of respective functions. The macros above (like luaL_do_lsp_file()) are really
+// just calling these functions indirectly via the pointer.
+static struct lsp_func lsp_sw[] = {
+  {"luaL_newstate", NULL},
+  {"luaL_openlibs", NULL},
+  {"luaopen_lualsp", NULL},
+  {"luaL_do_lsp_file", NULL},
+  {"lua_tolstring", NULL},
+  {"lua_settop", NULL},
+  {"lua_close", NULL},
+  {NULL,    NULL}
+};
+#endif // NO_LSP_DL
+
 static const char *month_names[] = {
   "Jan", "Feb", "Mar", "Apr", "May", "Jun",
   "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
@@ -381,6 +429,7 @@
 
 enum {
   CGI_EXTENSIONS, CGI_ENVIRONMENT, PUT_DELETE_PASSWORDS_FILE, CGI_INTERPRETER,
+  LSP_EXTENSIONS,
   PROTECT_URI, AUTHENTICATION_DOMAIN, SSI_EXTENSIONS, ACCESS_LOG_FILE,
   SSL_CHAIN_FILE, ENABLE_DIRECTORY_LISTING, ERROR_LOG_FILE,
   GLOBAL_PASSWORDS_FILE, INDEX_FILES,
@@ -395,6 +444,7 @@
   "E", "cgi_environment", NULL,
   "G", "put_delete_passwords_file", NULL,
   "I", "cgi_interpreter", NULL,
+  "L", "lsp_extensions", ".lsp",
   "P", "protect_uri", NULL,
   "R", "authentication_domain", "mydomain.com",
   "S", "ssi_extensions", ".shtml,.shtm",
@@ -2953,6 +3003,19 @@
 }
 #endif // !NO_CGI
 
+static void handle_lsp_file_request(struct mg_connection *conn,
+                                    const char *path) {
+  lua_State* L=lua_open();
+  luaL_openlibs(L);
+  luaopen_lualsp(L);
+  if(luaL_do_lsp_file(L, path)) {
+    const char* e=lua_tostring(L,-1);
+    mg_printf(conn, "%s", e);
+    lua_pop(L,1);
+  }
+  lua_close(L);
+}
+
 // For a given PUT path, create all intermediate subdirectories
 // for given path. Return 0 if the path itself is a directory,
 // or -1 on error, 1 if OK.
@@ -3226,6 +3289,14 @@
     } else {
       handle_cgi_request(conn, path);
     }
+  } else if (match_extension(path, conn->ctx->config[LSP_EXTENSIONS])) {
+    if (strcmp(ri->request_method, "POST") &&
+        strcmp(ri->request_method, "GET")) {
+      send_http_error(conn, 501, "Not Implemented",
+          "Method %s is not implemented", ri->request_method);
+    } else {
+      handle_lsp_file_request(conn, path);
+    }
   } else if (match_extension(path, conn->ctx->config[SSI_EXTENSIONS])) {
     handle_ssi_file_request(conn, path);
   } else if (is_not_modified(conn, &st)) {
@@ -3573,6 +3644,53 @@
 }
 #endif // !NO_SSL
 
+#if !defined(NO_LSP)
+#if !defined(NO_LSP_DL)
+static int load_lsp_dll(struct mg_context *ctx, const char *dll_name,
+                    struct lsp_func *sw) {
+  union {void *p; void (*fp)(void);} u;
+  void  *dll_handle;
+  struct lsp_func *fp;
+
+  if ((dll_handle = dlopen(dll_name, RTLD_LAZY)) == NULL) {
+    cry(fc(ctx), "%s: cannot load %s", __func__, dll_name);
+    return 0;
+  }
+
+  for (fp = sw; fp->name != NULL; fp++) {
+#ifdef _WIN32
+    // GetProcAddress() returns pointer to function
+    u.fp = (void (*)(void)) dlsym(dll_handle, fp->name);
+#else
+    // dlsym() on UNIX returns void *. ISO C forbids casts of data pointers to
+    // function pointers. We need to use a union to make a cast.
+    u.p = dlsym(dll_handle, fp->name);
+#endif /* _WIN32 */
+    if (u.fp == NULL) {
+      cry(fc(ctx), "%s: %s: cannot find %s", __func__, dll_name, fp->name);
+      return 0;
+    } else {
+      fp->ptr = u.fp;
+    }
+  }
+
+  return 1;
+}
+#endif // NO_LSP_DL
+
+// Dynamically load LSP library.
+static int set_lsp_option(struct mg_context *ctx) {
+
+#if !defined(NO_LSP_DL)
+  if (!load_lsp_dll(ctx, LSP_LIB, lsp_sw)) {
+    return 0;
+  }
+#endif // NO_LSP_DL
+
+  return 1;
+}
+#endif // !NO_LSP
+
 static int set_gpass_option(struct mg_context *ctx) {
   struct mgstat mgstat;
   const char *path = ctx->config[GLOBAL_PASSWORDS_FILE];
@@ -4039,6 +4157,9 @@
 #if !defined(NO_SSL)
       !set_ssl_option(ctx) ||
 #endif
+#if !defined(NO_LSP)
+      !set_lsp_option(ctx) ||
+#endif
       !set_ports_option(ctx) ||
 #if !defined(_WIN32)
       !set_uid_option(ctx) ||
